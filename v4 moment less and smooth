import tkinter as tk
from tkinter import ttk, messagebox
from adafruit_servokit import ServoKit
import threading
import time

# ------------------ HARDWARE SETUP ------------------
kit = ServoKit(channels=16)

BASE = 0
THIGH = 1
INDEFECTOR = 2
GRIPPER = 3

NEUTRAL_ANGLE = 90

current_angle = {
    BASE: NEUTRAL_ANGLE,
    THIGH: NEUTRAL_ANGLE,
    INDEFECTOR: NEUTRAL_ANGLE,
    GRIPPER: NEUTRAL_ANGLE
}

for ch in current_angle:
    try:
        kit.servo[ch].angle = NEUTRAL_ANGLE
    except:
        pass


# ------------------ MOVEMENT FUNCTIONS ------------------
def set_servo_angle(channel, angle):
    angle = max(0, min(180, int(angle)))
    kit.servo[channel].angle = angle
    current_angle[channel] = angle


def single_step(channel, step):
    """Single click -> EXACT 10° step"""
    target = max(0, min(180, current_angle[channel] + step))
    current_angle[channel] = target
    kit.servo[channel].angle = target


running_flags = {}
hold_timers = {}


def start_continuous(channel, step):
    running_flags[channel] = True

    def run():
        while running_flags.get(channel, False):
            target = max(0, min(180, current_angle[channel] + step))
            current_angle[channel] = target
            kit.servo[channel].angle = target
            time.sleep(speed_slider.get() / 1000)

    threading.Thread(target=run, daemon=True).start()


def stop_continuous(channel):
    running_flags[channel] = False


def create_pulse_button(parent, label, channel, step, row, col):
    btn = tk.Button(parent, text=label, width=12)

    # ------------------------------------------------------
    # *** NEW FIXED LOGIC ***
    # Single click = step
    # Press >150ms = continuous
    # ------------------------------------------------------
    def on_press(e, ch=channel, st=step):
        running_flags[ch] = False  # not holding yet

        def check_hold():
            if hold_timers.get(ch) == timer_id:
                running_flags[ch] = True
                start_continuous(ch, st)

        timer_id = root.after(150, check_hold)
        hold_timers[ch] = timer_id

    def on_release(e, ch=channel, st=step):
        try:
            root.after_cancel(hold_timers[ch])
        except:
            pass

        if running_flags.get(ch) is False:
            single_step(ch, st)

        running_flags[ch] = False

    btn.bind("<ButtonPress-1>", on_press)
    btn.bind("<ButtonRelease-1>", on_release)

    btn.grid(row=row, column=col, padx=4, pady=4)
    return btn


# ------------------ GUI ------------------
root = tk.Tk()
root.title("Motion Programmer — Manual + Sequence")


# ---------- Manual sliders ----------
top = tk.LabelFrame(root, text="Manual Controls")
top.grid(row=0, column=0, padx=8, pady=8, sticky="ew")


def add_slider(row, text, ch):
    tk.Label(top, text=text).grid(row=row, column=0, sticky="w")
    s = tk.Scale(top, from_=0, to=180, orient=tk.HORIZONTAL,
                 command=lambda val: set_servo_angle(ch, val),
                 length=300)
    s.set(90)
    s.grid(row=row, column=1)
    return s


base_slider = add_slider(0, "Base", BASE)
thigh_slider = add_slider(1, "Thigh", THIGH)
indef_slider = add_slider(2, "Indefector", INDEFECTOR)
grip_slider = add_slider(3, "Gripper", GRIPPER)

tk.Label(top, text="Speed (ms)").grid(row=4, column=0, sticky="w")
speed_slider = tk.Scale(top, from_=50, to=1000, orient=tk.HORIZONTAL)
speed_slider.set(200)
speed_slider.grid(row=4, column=1)


# ---------- Manual Pulse Buttons ----------
btnframe = tk.LabelFrame(root, text="Manual 10° Buttons (Hold = Continuous)")
btnframe.grid(row=1, column=0, padx=8, pady=8)

create_pulse_button(btnframe, "Base Left", BASE, -10, 0, 0)
create_pulse_button(btnframe, "Base Right", BASE, +10, 0, 1)
create_pulse_button(btnframe, "Thigh Up", THIGH, -10, 0, 2)
create_pulse_button(btnframe, "Thigh Down", THIGH, +10, 0, 3)
create_pulse_button(btnframe, "Ind Up", INDEFECTOR, +10, 1, 0)
create_pulse_button(btnframe, "Ind Down", INDEFECTOR, -10, 1, 1)
create_pulse_button(btnframe, "Grip Front", GRIPPER, +10, 1, 2)
create_pulse_button(btnframe, "Grip Back", GRIPPER, -10, 1, 3)


# ------------------ Sequence Table ------------------
seq = tk.LabelFrame(root, text="Sequence Table (Double-click to Edit)")
seq.grid(row=2, column=0, padx=8, pady=8, sticky="nsew")

cols = ("motor", "direction", "step", "count", "duration")
tree = ttk.Treeview(seq, columns=cols, show="headings", height=8)
for c in cols:
    tree.heading(c, text=c.capitalize())
    tree.column(c, width=120, anchor="center")

tree.grid(row=0, column=0, columnspan=4, sticky="nsew")

scroll = ttk.Scrollbar(seq, orient="vertical", command=tree.yview)
tree.configure(yscroll=scroll.set)
scroll.grid(row=0, column=4, sticky="ns")

MOTOR_LIST = ["Base", "Thigh", "Indefector", "Gripper"]
DIR_MAP = {
    "Base": ["Left", "Right"],
    "Thigh": ["Up", "Down"],
    "Indefector": ["Up", "Down"],
    "Gripper": ["Front", "Back"],
}


def add_row():
    tree.insert("", "end", values=("Base", "Left", "10", "3", "300"))


def del_row():
    for s in tree.selection():
        tree.delete(s)


tk.Button(seq, text="Add Row", command=add_row).grid(row=1, column=0)
tk.Button(seq, text="Delete Row", command=del_row).grid(row=1, column=1)


# ---------- Editable Cells (Dropdown + Entry) ----------
def on_double_click(event):
    item = tree.identify_row(event.y)
    col = tree.identify_column(event.x)
    if not item or not col:
        return

    c = int(col.replace("#", "")) - 1
    colname = cols[c]
    x, y, w, h = tree.bbox(item, col)
    old = tree.set(item, colname)

    # ---------- Motor Dropdown ----------
    if colname == "motor":
        topw = tk.Toplevel(root)
        topw.overrideredirect(True)
        topw.geometry(f"{w}x{h}+{tree.winfo_rootx()+x}+{tree.winfo_rooty()+y}")

        cb = ttk.Combobox(topw, values=MOTOR_LIST, state="readonly")
        cb.set(old)
        cb.pack(fill="both", expand=True)

        def save(e=None):
            motor = cb.get()
            tree.set(item, colname, motor)
            # auto-fix direction
            if tree.set(item, "direction") not in DIR_MAP[motor]:
                tree.set(item, "direction", DIR_MAP[motor][0])
            topw.destroy()

        cb.bind("<Return>", save)
        cb.bind("<FocusOut>", lambda e: topw.destroy())
        return

    # ---------- Direction Dropdown ----------
    if colname == "direction":
        motor = tree.set(item, "motor")
        allowed = DIR_MAP[motor]

        topw = tk.Toplevel(root)
        topw.overrideredirect(True)
        topw.geometry(f"{w}x{h}+{tree.winfo_rootx()+x}+{tree.winfo_rooty()+y}")

        cb = ttk.Combobox(topw, values=allowed, state="readonly")
        cb.set(old)
        cb.pack(fill="both", expand=True)

        def save(e=None):
            tree.set(item, colname, cb.get())
            topw.destroy()

        cb.bind("<Return>", save)
        cb.bind("<FocusOut>", lambda e: topw.destroy())
        return

    # ---------- Numeric Editor ----------
    topw = tk.Toplevel(root)
    topw.overrideredirect(True)
    topw.geometry(f"{w}x{h}+{tree.winfo_rootx()+x}+{tree.winfo_rooty()+y}")

    e = tk.Entry(topw)
    e.insert(0, old)
    e.pack(fill="both", expand=True)
    e.focus()

    def save_num(e2=None):
        try:
            float(e.get())
            tree.set(item, colname, e.get())
        except:
            pass
        topw.destroy()

    e.bind("<Return>", save_num)
    e.bind("<FocusOut>", lambda e: topw.destroy())


tree.bind("<Double-1>", on_double_click)


# ------------------ Sequence Runner ------------------
stop_event = threading.Event()


def motor_ch(m):
    return {"Base": BASE, "Thigh": THIGH, "Indefector": INDEFECTOR,
            "Gripper": GRIPPER}[m]


def dir_sign(m, d):
    return -1 if d in ["Left", "Up", "Back"] else +1


def run_sequence(wait_s):
    while not stop_event.is_set():
        for iid in tree.get_children():
            if stop_event.is_set():
                break

            motor, direction, step_s, count_s, dur_s = tree.item(iid, "values")
            step = float(step_s)
            cnt = int(float(count_s))
            dur = float(dur_s) / 1000.0

            ch = motor_ch(motor)
            signed = dir_sign(motor, direction) * step

            for _ in range(cnt):
                if stop_event.is_set():
                    break
                single_step(ch, signed)
                time.sleep(dur)

        # Wait between loops
        t = float(wait_s)
        for _ in range(int(t)):
            if stop_event.is_set(): break
            time.sleep(1)
        if not stop_event.is_set():
            time.sleep(t % 1)


def start_seq():
    stop_event.clear()
    twait = float(wait_entry.get())
    threading.Thread(target=run_sequence, args=(twait,), daemon=True).start()


def stop_seq():
    stop_event.set()


ctrl = tk.Frame(root)
ctrl.grid(row=3, column=0, pady=8)

tk.Label(ctrl, text="Loop Wait (s)").grid(row=0, column=0)
wait_entry = tk.Entry(ctrl, width=8)
wait_entry.insert(0, "5")
wait_entry.grid(row=0, column=1)

tk.Button(ctrl, text="Start Sequence", command=start_seq, bg="green", fg="white")\
    .grid(row=0, column=2, padx=5)
tk.Button(ctrl, text="Stop", command=stop_seq, bg="red", fg="white")\
    .grid(row=0, column=3, padx=5)

root.mainloop()
